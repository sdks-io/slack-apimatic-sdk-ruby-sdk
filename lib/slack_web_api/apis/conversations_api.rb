# slack_web_api
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module SlackWebApi
  # ConversationsApi
  class ConversationsApi < BaseApi
    # Archives a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: ID of conversation to
    # archive
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_archive(token: nil,
                              channel: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.archive',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsArchiveSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsArchiveErrorSchemaException))
        .execute
    end

    # Closes a direct message or multi-person direct message.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Conversation to close.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_close(token: nil,
                            channel: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.close',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsCloseSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsCloseErrorSchemaException))
        .execute
    end

    # Initiates a public or private channel-based conversation
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] name Optional parameter: Name of the public or private
    # channel to create
    # @param [TrueClass | FalseClass] is_private Optional parameter: Create a
    # private channel instead of a public one
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_create(token: nil,
                             name: nil,
                             is_private: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.create',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(name, key: 'name'))
                   .form_param(new_parameter(is_private, key: 'is_private'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsCreateSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when name already in use',
                                 ConversationsCreateErrorSchemaException))
        .execute
    end

    # Fetches a conversation's history of messages and events.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:history`
    # @param [String] channel Optional parameter: Conversation ID to fetch
    # history for.
    # @param [Float] latest Optional parameter: End of time range of messages to
    # include in results.
    # @param [Float] oldest Optional parameter: Start of time range of messages
    # to include in results.
    # @param [TrueClass | FalseClass] inclusive Optional parameter: Include
    # messages with latest or oldest timestamp in results only when either
    # timestamp is specified.
    # @param [Integer] limit Optional parameter: The maximum number of items to
    # return. Fewer than the requested number of items may be returned, even if
    # the end of the users list hasn't been reached.
    # @param [String] cursor Optional parameter: Paginate through collections of
    # data by setting the `cursor` parameter to a `next_cursor` attribute
    # returned by a previous request's `response_metadata`. Default value
    # fetches the first "page" of the collection.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_history(token: nil,
                              channel: nil,
                              latest: nil,
                              oldest: nil,
                              inclusive: nil,
                              limit: nil,
                              cursor: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::GET,
                                     '/conversations.history',
                                     Server::DEFAULT)
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'Content-Type'))
                   .query_param(new_parameter(token, key: 'token'))
                   .query_param(new_parameter(channel, key: 'channel'))
                   .query_param(new_parameter(latest, key: 'latest'))
                   .query_param(new_parameter(oldest, key: 'oldest'))
                   .query_param(new_parameter(inclusive, key: 'inclusive'))
                   .query_param(new_parameter(limit, key: 'limit'))
                   .query_param(new_parameter(cursor, key: 'cursor'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsHistorySuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsHistoryErrorSchemaException))
        .execute
    end

    # Retrieve information about a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:read`
    # @param [String] channel Optional parameter: Conversation ID to learn more
    # about
    # @param [TrueClass | FalseClass] include_locale Optional parameter: Set
    # this to `true` to receive the locale for this conversation. Defaults to
    # `false`
    # @param [TrueClass | FalseClass] include_num_members Optional parameter:
    # Set to `true` to include the member count for the specified conversation.
    # Defaults to `false`
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_info(token: nil,
                           channel: nil,
                           include_locale: nil,
                           include_num_members: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::GET,
                                     '/conversations.info',
                                     Server::DEFAULT)
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'Content-Type'))
                   .query_param(new_parameter(token, key: 'token'))
                   .query_param(new_parameter(channel, key: 'channel'))
                   .query_param(new_parameter(include_locale, key: 'include_locale'))
                   .query_param(new_parameter(include_num_members, key: 'include_num_members'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsInfoSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when a channel cannot be found',
                                 ConversationsInfoErrorSchemaException))
        .execute
    end

    # Invites users to a channel.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: The ID of the public or
    # private channel to invite user(s) to.
    # @param [String] users Optional parameter: A comma separated list of user
    # IDs. Up to 1000 users may be listed.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_invite(token: nil,
                             channel: nil,
                             users: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.invite',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(users, key: 'users'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsInviteErrorSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when an invite is attempted on a'\
                                  ' conversation type that does not support it',
                                 ConversationsInviteErrorSchema1Exception))
        .execute
    end

    # Joins an existing conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `channels:write`
    # @param [String] channel Optional parameter: ID of conversation to join
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_join(token: nil,
                           channel: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.join',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsJoinSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response if the conversation is archived and'\
                                  ' cannot be joined',
                                 ConversationsJoinErrorSchemaException))
        .execute
    end

    # Removes a user from a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: ID of conversation to remove
    # user from.
    # @param [String] user Optional parameter: User ID to be removed.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_kick(token: nil,
                           channel: nil,
                           user: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.kick',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(user, key: 'user'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsKickSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when you attempt to kick yourself from'\
                                  ' a channel',
                                 ConversationsKickErrorSchemaException))
        .execute
    end

    # Leaves a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Conversation to leave
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_leave(token: nil,
                            channel: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.leave',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsLeaveSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when attempting to leave a workspace\'s'\
                                  ' "general" channel',
                                 ConversationsLeaveErrorSchemaException))
        .execute
    end

    # Lists all channels in a Slack team.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:read`
    # @param [TrueClass | FalseClass] exclude_archived Optional parameter: Set
    # to `true` to exclude archived channels from the list
    # @param [String] types Optional parameter: Mix and match channel types by
    # providing a comma-separated list of any combination of `public_channel`,
    # `private_channel`, `mpim`, `im`
    # @param [Integer] limit Optional parameter: The maximum number of items to
    # return. Fewer than the requested number of items may be returned, even if
    # the end of the list hasn't been reached. Must be an integer no larger than
    # 1000.
    # @param [String] cursor Optional parameter: Paginate through collections of
    # data by setting the `cursor` parameter to a `next_cursor` attribute
    # returned by a previous request's `response_metadata`. Default value
    # fetches the first "page" of the collection.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_list(token: nil,
                           exclude_archived: nil,
                           types: nil,
                           limit: nil,
                           cursor: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::GET,
                                     '/conversations.list',
                                     Server::DEFAULT)
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'Content-Type'))
                   .query_param(new_parameter(token, key: 'token'))
                   .query_param(new_parameter(exclude_archived, key: 'exclude_archived'))
                   .query_param(new_parameter(types, key: 'types'))
                   .query_param(new_parameter(limit, key: 'limit'))
                   .query_param(new_parameter(cursor, key: 'cursor'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsListSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsListErrorSchemaException))
        .execute
    end

    # Sets the read cursor in a channel.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Channel or conversation to set
    # the read cursor for.
    # @param [Float] ts Optional parameter: Unique identifier of message you
    # want marked as most recently seen in this conversation.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_mark(token: nil,
                           channel: nil,
                           ts: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.mark',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(ts, key: 'ts'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsMarkSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsMarkErrorSchemaException))
        .execute
    end

    # Retrieve members of a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:read`
    # @param [String] channel Optional parameter: ID of the conversation to
    # retrieve members for
    # @param [Integer] limit Optional parameter: The maximum number of items to
    # return. Fewer than the requested number of items may be returned, even if
    # the end of the users list hasn't been reached.
    # @param [String] cursor Optional parameter: Paginate through collections of
    # data by setting the `cursor` parameter to a `next_cursor` attribute
    # returned by a previous request's `response_metadata`. Default value
    # fetches the first "page" of the collection.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_members(token: nil,
                              channel: nil,
                              limit: nil,
                              cursor: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::GET,
                                     '/conversations.members',
                                     Server::DEFAULT)
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'Content-Type'))
                   .query_param(new_parameter(token, key: 'token'))
                   .query_param(new_parameter(channel, key: 'channel'))
                   .query_param(new_parameter(limit, key: 'limit'))
                   .query_param(new_parameter(cursor, key: 'cursor'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsMembersSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when an invalid cursor is provided',
                                 ConversationsMembersErrorSchemaException))
        .execute
    end

    # Opens or resumes a direct message or multi-person direct message.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Resume a conversation by
    # supplying an `im` or `mpim`'s ID. Or provide the `users` field instead.
    # @param [String] users Optional parameter: Comma separated lists of users.
    # If only one user is included, this creates a 1:1 DM.  The ordering of the
    # users is preserved whenever a multi-person direct message is returned.
    # Supply a `channel` when not supplying `users`.
    # @param [TrueClass | FalseClass] return_im Optional parameter: Boolean,
    # indicates you want the full IM channel definition in the response.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_open(token: nil,
                           channel: nil,
                           users: nil,
                           return_im: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.open',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(users, key: 'users'))
                   .form_param(new_parameter(return_im, key: 'return_im'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsOpenSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsOpenErrorSchemaException))
        .execute
    end

    # Renames a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: ID of conversation to rename
    # @param [String] name Optional parameter: New name for conversation.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_rename(token: nil,
                             channel: nil,
                             name: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.rename',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(name, key: 'name'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsRenameSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response when the calling user is not a member'\
                                  ' of the conversation',
                                 ConversationsRenameErrorSchemaException))
        .execute
    end

    # Retrieve a thread of messages posted to a conversation
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:history`
    # @param [String] channel Optional parameter: Conversation ID to fetch
    # thread from.
    # @param [Float] ts Optional parameter: Unique identifier of a thread's
    # parent message. `ts` must be the timestamp of an existing message with 0
    # or more replies. If there are no replies then just the single message
    # referenced by `ts` will return - it is just an ordinary, unthreaded
    # message.
    # @param [Float] latest Optional parameter: End of time range of messages to
    # include in results.
    # @param [Float] oldest Optional parameter: Start of time range of messages
    # to include in results.
    # @param [TrueClass | FalseClass] inclusive Optional parameter: Include
    # messages with latest or oldest timestamp in results only when either
    # timestamp is specified.
    # @param [Integer] limit Optional parameter: The maximum number of items to
    # return. Fewer than the requested number of items may be returned, even if
    # the end of the users list hasn't been reached.
    # @param [String] cursor Optional parameter: Paginate through collections of
    # data by setting the `cursor` parameter to a `next_cursor` attribute
    # returned by a previous request's `response_metadata`. Default value
    # fetches the first "page" of the collection.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_replies(token: nil,
                              channel: nil,
                              ts: nil,
                              latest: nil,
                              oldest: nil,
                              inclusive: nil,
                              limit: nil,
                              cursor: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::GET,
                                     '/conversations.replies',
                                     Server::DEFAULT)
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'Content-Type'))
                   .query_param(new_parameter(token, key: 'token'))
                   .query_param(new_parameter(channel, key: 'channel'))
                   .query_param(new_parameter(ts, key: 'ts'))
                   .query_param(new_parameter(latest, key: 'latest'))
                   .query_param(new_parameter(oldest, key: 'oldest'))
                   .query_param(new_parameter(inclusive, key: 'inclusive'))
                   .query_param(new_parameter(limit, key: 'limit'))
                   .query_param(new_parameter(cursor, key: 'cursor'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsRepliesSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsRepliesErrorSchemaException))
        .execute
    end

    # Sets the purpose for a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Conversation to set the
    # purpose of
    # @param [String] purpose Optional parameter: A new, specialer purpose
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_set_purpose(token: nil,
                                  channel: nil,
                                  purpose: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.setPurpose',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(purpose, key: 'purpose'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsSetPurposeSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsSetPurposeErrorSchemaException))
        .execute
    end

    # Sets the topic for a conversation.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: Conversation to set the topic
    # of
    # @param [String] topic Optional parameter: The new topic string. Does not
    # support formatting or linkification.
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_set_topic(token: nil,
                                channel: nil,
                                topic: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.setTopic',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .form_param(new_parameter(topic, key: 'topic'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsSetTopicSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsSetTopicErrorSchemaException))
        .execute
    end

    # Reverses conversation archival.
    # @param [String] token Optional parameter: Authentication token. Requires
    # scope: `conversations:write`
    # @param [String] channel Optional parameter: ID of conversation to
    # unarchive
    # @return [ApiResponse] Complete http response with raw body and status code.
    def conversations_unarchive(token: nil,
                                channel: nil)
      @api_call
        .request(new_request_builder(HttpMethodEnum::POST,
                                     '/conversations.unarchive',
                                     Server::DEFAULT)
                   .header_param(new_parameter(token, key: 'token'))
                   .form_param(new_parameter(channel, key: 'channel'))
                   .header_param(new_parameter('application/x-www-form-urlencoded', key: 'content-type'))
                   .header_param(new_parameter('application/json', key: 'accept'))
                   .auth(Single.new('slackAuth')))
        .response(new_response_handler
                    .deserializer(APIHelper.method(:custom_type_deserializer))
                    .deserialize_into(ConversationsUnarchiveSuccessSchema.method(:from_hash))
                    .is_api_response(true)
                    .local_error('default',
                                 'Typical error response',
                                 ConversationsUnarchiveErrorSchemaException))
        .execute
    end
  end
end
